[TOC]

## 2020/01/03

1. 初始化了学习记录用的仓库
2. 完成7道算法题
3. LeakCanary原理学习，理解了初始化逻辑和对生命周期检测的原理，使用了IdleHandler。

### 归并排序

核心思想就是分治，将大问题分解为小问题治理，主要的方法依靠的是递归，将数组每次从低位**lo**和高位**hi**的中间分开，然后分别对左右两边排序；

最主要的处理在最后合并的时候，我们可以从最小的单位来梳理逻辑代码，也就是最小划分要么左边一个数，右边两个数（或者反过来左边两个，右边一个），要么是左右各一个数进行排序，后者是前者的特殊情况，分析前者就行了。整个数组三个数，重新排序，index从左到有，依次比较左右的大小，谁小谁排前面，拷贝的时候，小的那边就加一，进行遍历。当index大于了右边的时候，最小单位的排序也就完了。最小单位的情况分析完了就往上一层走，对于左右两边，如果left已经大于了mid，说明左边的排序已经完成了，直接就可以开始拷贝右边了，如果right大于了hi，说明右边的排序处理完了，就可以拷贝左边了。

这个算法是稳定的算法，时间复杂度是$O(n\log{n})$，空间复杂度是$O(1)$。 

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/mergeSort.png)

### 快速排序

快排是在归并的基础上进一步优化，在归并排序中，因为每次都选的中间位置开始划分数组，所以划分的次数是一定的，这是它稳定的原因。快排通过每次分割数组的点随机化来打破这种稳定。

这样要是运气好，随机到的点正好遍历一次就可以把数组排好序，那就是$O(n)$，要是运气不好，那最差也就是回到稳定排序的程度，和归并排序的复杂度一样$O(n \log{n})$

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/quick.png)

### 寻找数组中第K大的数

这个题目要求是给了一个无序的数组，要找到第k大的那个数，直接一点能想到的解法就是先对数组排序，然后根据下标就能获取到。但是这样的思路还可以用快排来更进一步优化，我们需要寻找的是第k大的数，也就是说只需要排序好前k个数就行了，当快排随机的基点等于前k的大小时，这次排序好后的数组的**基点**值真好就是第K大的数了（因为快排每次会把小于等于基点的数排在基点左边，大于的排在右边）

代码如下:

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/lastKWithQuick.png)

还有一种巧妙的思路，就是利用最小堆，最小堆每次添加元素时，会按照大小排序，寻找第k大的数，将堆大小维护在K值，在添加完数组数据后，位置堆定的就是我们需要的了，这个代码非常简洁易懂。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/lastKWithPriority.png)