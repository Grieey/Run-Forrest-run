[TOC]

## 2021/01/03

1. 初始化了学习记录用的仓库
2. 完成7道算法题
3. LeakCanary原理学习，在2.0之前，leakCanary的初始化是使用的**IdleHandler**，它会判断是否在主线程，是主线程就会使用这个，等待主线程空闲时进行初始化，并只初始化一次；2.0之后是利用的**ContenProvider**来出初始化的，这个会在Application之前调用。监测生命周期利用的是弱引用和引用队列。

### 归并排序

核心思想就是分治，将大问题分解为小问题治理，主要的方法依靠的是递归，将数组每次从低位**lo**和高位**hi**的中间分开，然后分别对左右两边排序；

最主要的处理在最后合并的时候，我们可以从最小的单位来梳理逻辑代码，也就是最小划分要么左边一个数，右边两个数（或者反过来左边两个，右边一个），要么是左右各一个数进行排序，后者是前者的特殊情况，分析前者就行了。整个数组三个数，重新排序，index从左到有，依次比较左右的大小，谁小谁排前面，拷贝的时候，小的那边就加一，进行遍历。当index大于了右边的时候，最小单位的排序也就完了。最小单位的情况分析完了就往上一层走，对于左右两边，如果left已经大于了mid，说明左边的排序已经完成了，直接就可以开始拷贝右边了，如果right大于了hi，说明右边的排序处理完了，就可以拷贝左边了。

这个算法是稳定的算法，时间复杂度是$O(n\log{n})$，空间复杂度是$O(1)$。 

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/mergeSort.png)

### 快速排序

快排是在归并的基础上进一步优化，在归并排序中，因为每次都选的中间位置开始划分数组，所以划分的次数是一定的，这是它稳定的原因。快排通过每次分割数组的点随机化来打破这种稳定。

这样要是运气好，随机到的点正好遍历一次就可以把数组排好序，那就是$O(n)$，要是运气不好，那最差也就是回到稳定排序的程度，和归并排序的复杂度一样$O(n \log{n})$

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/quick.png)

### 寻找数组中第K大的数

这个题目要求是给了一个无序的数组，要找到第k大的那个数，直接一点能想到的解法就是先对数组排序，然后根据下标就能获取到。但是这样的思路还可以用快排来更进一步优化，我们需要寻找的是第k大的数，也就是说只需要排序好前k个数就行了，当快排随机的基点等于前k的大小时，这次排序好后的数组的**基点**值真好就是第K大的数了（因为快排每次会把小于等于基点的数排在基点左边，大于的排在右边）

代码如下:

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/lastKWithQuick.png)

还有一种巧妙的思路，就是利用最小堆，最小堆每次添加元素时，会按照大小排序，寻找第k大的数，将堆大小维护在K值，在添加完数组数据后，位置堆定的就是我们需要的了，这个代码非常简洁易懂。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/lastKWithPriority.png)

## 2021/01/04

- 完成三道算法题
- 看了一遍小专栏的Handler源码分析，想想自己写的时候需要的大纲

###[节点间通路](https://leetcode-cn.com/problems/route-between-nodes-lcci/)

这个题目一看题目，首先是懵逼的，题都不太懂，主要是没有明白这个`graph`数组所代表的意思，后来搜了一下知道，数组中的每一个数组代表的是从多少到多少的连接，没有方向。这下思路就开朗了。使用**BFS**进行遍历不就完了，结果调试的数据是没有问题的，提交上去就超时，一看用例。。。。十万个节点的图(这用例我拷贝到idea中，idea直接崩了=。=)，那就是应该没有优化遍历的问题。我观察数组，发现子数组第一个值是有序递增的，那就是记录开始的位置进行遍历，后来一想，不对呀，随着遍历的深入，前一个点连接的后一个点是不知道连接到哪儿的，如果用**BFS**一个一个添加，那么在数组中的位置就不是挨着遍历的。。。

```
节点间通路。给定有向图，设计一个算法，找出两个节点之间是否存在一条路径。

示例1:

 输入：n = 3, graph = [[0, 1], [0, 2], [1, 2], [1, 2]], start = 0, target = 2
 输出：true
示例2:

 输入：n = 5, graph = [[0, 1], [0, 2], [0, 4], [0, 4], [0, 1], [1, 3], [1, 4], [1, 3], [2, 3], [3, 4]], start = 0, target = 4
 输出 true
```

最后看了答案，知道了[邻接表](https://zh.wikipedia.org/wiki/%E9%82%BB%E6%8E%A5%E8%A1%A8)这个东西，他基本就是我前面思路的实现方案了，通过建立邻接表，将节点的起点都放在一起，去遍历就方便多了。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/whetherExist.png)

### [ 特定深度节点链表](https://leetcode-cn.com/problems/list-of-depth-lcci/)

这道题一开始想的是用递归，发现好像不行，递归无法知道兄弟节点的子树情况。所以改变思路用的**BFS**，**BFS**处理起来思路就比较简单了，将每一层的**parent**节点添加到队列中，然后遍历，一次添加到链表中即可。对我自己来说，需要注意的就是这个头结点的用法，因为第一遍写的时候，用了很多判断来出来头结点的问题。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/listOfDeath.png)

## 2021/01/05

- 完成了三道算法题
- 读了一遍hashmap和concurrenthashmap的源码，整理了源码的注释，了解到了UnSafe工具包
- 了解了下内存泄漏的一些方案。

### [检查平衡性](https://leetcode-cn.com/problems/check-balance-lcci/)

这个题对于练习二叉树的遍历有比较好的价值，所以记录一下，题目要求是检查二叉树是否是平衡的（任意左右子树的高度差不超过1），看到这道题的思路就是，递归计算左右子树的高度，但是也有个问题，就是当你在某个子树判断时，已经得出这棵树非平衡二叉树了，怎么结束递归呢？开始我想的是返回` Boolean`，但这样又没法计算高度，所以就用一个负值来代替`false`的情况。

代码如下

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/isBalanced.png)

### [合法二叉搜索树](https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/)

这个题我知道思路，需要借助额外的参数来比较子树与根root的大小，但是细节上还是没控制好，下面的代码逻辑比较巧妙的地方在于，他没有在当前节点去比较左右子树和当前root的合法性（这其实是书上一开始指出的错误思路，而我就是这样做的，就陷入了死胡同），而是先比较了当前root和父节点的合法性，这样就保证了到当前root为止，都是符合**BST(二叉搜索树)**的规则的，接下来需要做的事就是向下遍历去判断子树是否也符合了，而且因为数字左右是递减和递增的关系，那么前面的合法性判断就能很好的传承下去（当前root假设是左子树的节点，已经通过了`max != null && root.val >= max.val`这句的判断，那对子树来说，左右子树的`val`肯定是都需要符合小于`root.val`，这样判断就是依次递减的一个逻辑，只要出现了大于父节点的`root.val`，就非法了）

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/isValidBST.png)

### [后继者](https://leetcode-cn.com/problems/successor-lcci/)

这个题目一开始我想的是，像检查合法性一样，利用递归遍历每个节点，然后找到目标节点后，去拿到他的下一个节点，但是在写代码的过程中就发现事情没有这么简单，因为是中序遍历的后继节点，那么目标节点的位置就可以分好几种情况，例如目标节点正好的某个父节点的时候，需要判断右子树的情况，如果右子树为null，就是它的父节点，但是在递归中拿父节点是很不好操作的，到这里，这个思路基本就可以宣告无法执行了。

题目还有条件是这是一颗**BST**，利用它的性质可以搞事情。我们先以寻找目标节点为目的，如果目标节点的值小于当前节点，说明在左子树，继续遍历；大于了，就是在右子树，也继续遍历；等于了呢？等于的话结果就出来了，就是右子树最左边的节点，这个时候就需要一直赋值左子树的值了，那这个操作和前面的遍历左子树有什么区别么？并没有区别，你想想看遍历左子树的目的是什么，是寻找目标值，之所以在左子树寻找是因为当前节点的值大于了目标值，而寻找右子树最左边的节点，这个节点有什么性质，性质就是它正好是整颗右子树中第一个比目标值大的节点。

最有意思的是遍历的退出条件，对于需要寻找的节点来说，目标节点可能位于左叶子、右叶子和根。那么最开始我们疑虑的如果是右叶子如何去寻找父节点的父节点的问题，就可以通过两个指针来解决，先将结果指向父节点的父节点，另一个指针指向父节点，然后去判断父节点的情况，如果目标值小于父节点了，极端情况就是它就是左叶子，那么这个时候两个指针同时向左前一步，结果节点指向了父节点，另一个指针指向了左叶子，这个相等了，赋值右节点，是个**null**，退出循环；如果目标值等于父节点，那么结果是右子树的左边的左叶子，情况和左子树的遍历一样；如果目标值大于了父节点，也极端一点就是右叶子了，结果要么是右叶子的右节点，要么就是父节点的父节点，也就是现在结果指针指向的节点，这两种情况就在循环的判断条件里了，如果无右节点，赋值为**null**那么就退出了循环了，如果有，就会继续向下，重复等于的逻辑。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/inorderSuccessor.png)

## 2020/01/06

- 完成三道算法题

### [ 检查子树](https://leetcode-cn.com/problems/check-subtree-lcci/)

检查子树就是常规的二叉树的遍历，使用递归的方法，先找到目标子树，找到后再对比遍历就可以了。需要提一下的是这里是普通的二叉树，如果是二叉搜索树，还可以进一步优化搜索目标子树的逻辑，第二个是这存在一颗子树的节点一样，如果树中有多个节点的值和目标子树一样，需要用数组来保存所有的子树节点，然后遍历数组比较。相对来说，这道题思路比较简单。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/checkSubTree.png)

### [二叉搜索树序列](https://leetcode-cn.com/problems/bst-sequences-lcci/)

题目要求解出所有能够组成目标**BST**的可能数组，一旦题目中出现**所有**这个字眼儿，就可以考虑回溯算法，全排列的套路了。全排列的模板如下

```kotlin
fun backTrace() {
  if (xxx) {
  	// 结束条件，添加结果
      result.add(path)
  	return 
  }
  
  for ( 剩余选择) {
  	// 添加选择后的结果
      path.add(xx)
      // 向下遍历
  	backTrace()  
  	// 回溯
      path.remove()
  }
}
```

**剩余选择**的对象就是我们的叶子节点，所以这里需要一个队列来维护剩余节点，通过遍历剩余节点来遍历整颗树。当剩余节点为0时，说明树已经遍历完了，此时就是一个**路径**。接下来就是回溯，这个得分析下例题

```
示例：
给定如下二叉树

        2
       / \
      1   3
返回：

[
   [2,1,3],
   [2,3,1]
]

```

对于示例中这样的树，我们根据上面的模板能想到`[2,1,3]`这样的结果，首先添加的是`root`，这个时候的剩余选择是其两个子节点`1,3`，那么把剩余选择添加到队列中进行遍历，然后遍历顺序就是`1`，这个停下来想想流程，在一个**for**循环中，先拿到队列中的`1`节点，然后执行的是继续遍历`backTrace`，这个时候的队列中就只剩下了`3`，也就是说`3`在路径中的添加不是在第二层`1,3`的遍历中，而是在第二层遍历到`1`时进行下一层遍历时被添加的，然后才是添加`3`并进入`3`的下一层，这个时候队列为空，就添加了`[2,1,3]`。接下来回溯，要得到`[2,3,1]`，因为队列为空，回溯的目的肯定是将走过的路再添加回去，再看看前面的逻辑，有一点遗漏了，那就是在第二层遍历时，只处理完`1`就得到了一个路径，接下来遍历的应该是`3`，这样才会有`[2,3,1]`的结果，所以可以从这里去倒推逻辑，在处理第一个路径后，停留在`3`，此时队列为空，我们需要把数据插回队列以便后续的遍历，同时路径回退，而插回的顺序正好就是`[3,1]`(`3`插回后，回到第二层处理`1`处，这个时候也是把`1`插回队列)，这样在`1`结束后，遍历第二个数的时候就是`3`了，这个时候可能有疑问，此时的队列为`[3,1]`，第二个数不是`1`么，这个就是一个细节了，在全排列的遍历中，每一层的队列遍历代表的是次数，而不是从队列中根据索引去获取值，对每一个根节点来说，他遍历的次数最多两次（左右子树的选择），最少就是零次（叶子节点的下一层），对于每一层来说，遍历的次数就是这一层的所有节点说，所有从这里来解释，其实全排列的模板就是在树上一层一层的处理，每一层从左开始往叶子节点前进，直到这一层所有的节点都到达叶子节点。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/BSTSequences.png)

### [首个共同祖先](https://leetcode-cn.com/problems/first-common-ancestor-lcci/)

对于公共祖先节点，有两种情况，第一是这个节点的左右子树分别包含了`p、q`两个节点，那么这个节点就是公共节点，第二种情况就是这个节点本身等于`p或者q`，则另一个节点只能在左子树或者右子树了。所以换成代码就是，对于当前节点满足`root.val == p.val || root.val == q.val`，那包含这个节点的子树满足了情况一，或者对应情况二的前置条件，接下来就是分别判断情况一和情况二的后置条件了。情况一中，假设当前节点已经被包含在节点`x`的左子树或者右子树，需要判断的是另一个节点是否也包含在这个`x`节点的另一颗子树上，可以将包含作为遍历的结果返回，就是只需要判断哪个节点的左右子树，都满足包含`p或者q`，那这个节点就是公共祖先了。情况二的理解就更容易了，当前节点是`p、q`之一，只需要判断其子树之一是否包含剩下的节点就可以知道该节点是不是公共祖先了。

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/lowestCommonAncestor.png)

## 2021/01/07

- 完成了一道算法题
- 开始编写Handler的总结，从梳理代码逻辑开始，然后准备复盘到总结架构图、流程图和前置知识
- 在**Typora**中配置了图片上传代理，支持`PicGo`直接上传图床

### [求和路径](https://leetcode-cn.com/problems/paths-with-sum-lcci/)

这道题，一开始看完题目，我第一想到的使用回溯进行全排列，但是直接全排列没法满足任意一个节点开始。所以这里需要先使用遍历节点，以每个节点开始进行全排列来计算。

代码如下：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/pathSum_2Dfs.png)

这种算法的时间复杂度比较高$O(n^2)$，属于一种暴力解法。

答案区有个很精妙的答案，使用**前缀和+回溯算法**，前缀和就是达到当前节点的路径之和，那么把树上从`root`到当前节点的一条路径展开为线段，使用**当前节点A的路径和**减去**目标和**，这个差值如果是这一条路径上的**某个节点B的路径和**，那就说明**在节点A和节点B之间节点的节点和为我们的目标和**，用式子表示：`节点A路径和 - 目标和 = 节点B路径和`，而**节点B起(不包含节点B)到节点A，这一路径就是节点和等于目标和的路径**。在这种算法中，只需要遍历一次，存储所有节点的路径和，所有时间复杂度和空间复杂度都是$O(n)$。

做了一个动图，更直观的展示这一流程：

![](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/prefix_PathSum.gif)

 ## 2021/01/08

- **Kotlin**中对于二进制和十进制的转换

  ![trans_between_2_and_10](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/trans_between_2_and_10.png)



### [三步问题](https://leetcode-cn.com/problems/three-steps-problem-lcci/)

经典对于斐波那契数列的应用，用动态规划来做。

![waysToStep](https://cdn.jsdelivr.net/gh/Grieey/ImgHosting@main/img/waysToStep.png)